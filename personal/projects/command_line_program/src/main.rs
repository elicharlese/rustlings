// An I/O Project: Building a Command Line Program
// This chapter is a recap of the many skills you’ve learned so far and an exploration of a few more standard library features.
// We’ll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.

// Note: there are no quizzes in this chapter, since it is just supposed to be a hands-on walkthrough.

// Rust’s speed, safety, single binary output, and cross-platform support make it an ideal language for creating command line tools, so for our project, we’ll make our own version of the classic command line search tool grep (globally search a regular expression and print).
// In the simplest use case, grep searches a specified file for a specified string.
// To do so, grep takes as its arguments a file path and a string.
// Then it reads the file, finds lines in that file that contain the string argument, and prints those lines.

// Along the way, we’ll show how to make our command line tool use the terminal features that many other command line tools use.
// We’ll read the value of an environment variable to allow the user to configure the behavior of our tool.
// We’ll also print error messages to the standard error console stream (stderr) instead of standard output (stdout), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.

// One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of grep, called ripgrep. 
// By comparison, our version will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as ripgrep.

// Our grep project will combine a number of concepts you’ve learned so far:

// Organizing code (using what you learned about modules in Chapter 7)

// - Using vectors and strings (collections, Chapter 8)
// - Handling errors (Chapter 9)
// - Using traits and lifetimes where appropriate (Chapter 10)
// - Writing tests (Chapter 11)

// We’ll also briefly introduce closures, iterators, and trait objects, which Chapters 13 and 17 will cover in detail.

// Accepting Command Line Arguments
// Let’s create a new project with, as always, cargo new. We’ll call our project minigrep to distinguish it from the grep tool that you might already have on your system.

// $ cargo new minigrep
//      Created binary (application) `minigrep` project
// $ cd minigrep

// The first task is to make minigrep accept its two command line arguments: the file path and a string to search for.
// That is, we want to be able to run our program with cargo run, two hyphens to indicate the following arguments are for our program rather than for cargo, a string to search for, and a path to a file to search in, like so:

// Right now, the program generated by cargo new cannot process arguments we give it.
// Some existing libraries on crates.io can help with writing a program that accepts command line arguments, but because you’re just learning this concept, let’s implement this capability ourselves.

// Reading the Argument Values
// To enable minigrep to read the values of command line arguments we pass to it, we’ll need the std::env::args function provided in Rust’s standard library.
// This function returns an iterator of the command line arguments passed to minigrep.
// We’ll cover iterators fully in Chapter 13.
// For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the collect method on an iterator to turn it into a collection, such as a vector, that contains all the elements the iterator produces.

// The code in Listing 12-1 allows your minigrep program to read any command line arguments passed to it and then collect the values into a vector.

// use std::env;

// fn main() {
//     let args: Vec<String> = env::args().collect();
//     dbg!(args);
// }

// First, we bring the std::env module into scope with a use statement so we can use its args function.
// Notice that the std::env::args function is nested in two levels of modules.
// As we discussed in Chapter 7, in cases where the desired function is nested in more than one module, we’ve chosen to bring the parent module into scope rather than the function.
// By doing so, we can easily use other functions from std::env.
// It’s also less ambiguous than adding use std::env::args and then calling the function with just args, because args might easily be mistaken for a function that’s defined in the current module.

// The args Function and Invalid Unicode
// Note that std::env::args will panic if any argument contains invalid Unicode.
// If your program needs to accept arguments containing invalid Unicode, use std::env::args_os instead.
// That function returns an iterator that produces OsString values instead of String values.
// We’ve chosen to use std::env::args here for simplicity, because OsString values differ per platform and are more complex to work with than String values.

// On the first line of main, we call env::args, and we immediately use collect to turn the iterator into a vector containing all the values produced by the iterator.
// We can use the collect function to create many kinds of collections, so we explicitly annotate the type of args to specify that we want a vector of strings.
// Although we very rarely need to annotate types in Rust, collect is one function you do often need to annotate because Rust isn’t able to infer the kind of collection you want.

// Finally, we print the vector using the debug macro. Let’s try running the code first with no arguments and then with two arguments:

// $ cargo run
//    Compiling minigrep v0.1.0 (file:///projects/minigrep)
//     Finished dev [unoptimized + debuginfo] target(s) in 0.61s
//      Running `target/debug/minigrep`
// [src/main.rs:5] args = [
//     "target/debug/minigrep",
// ]

// $ cargo run -- needle haystack
//    Compiling minigrep v0.1.0 (file:///projects/minigrep)
//     Finished dev [unoptimized + debuginfo] target(s) in 1.57s
//      Running `target/debug/minigrep needle haystack`
// [src/main.rs:5] args = [
//     "target/debug/minigrep",
//     "needle",
//     "haystack",
// ]

// Notice that the first value in the vector is "target/debug/minigrep", which is the name of our binary.
// This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It’s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program.
// But for the purposes of this chapter, we’ll ignore it and save only the two arguments we need.

// Saving the Argument Values in Variables
// The program is currently able to access the values specified as command line arguments.
// Now we need to save the values of the two arguments in variables so we can use the values throughout the rest of the program.
// We do that in Listing 12-2.

// use std::env;

// fn main() {
//     let args: Vec<String> = env::args().collect();

//     let query = &args[1];
//     let file_path = &args[2];

//     println!("Searching for {}", query);
//     println!("In file {}", file_path);
// }

// As we saw when we printed the vector, the program’s name takes up the first value in the vector at args[0], so we’re starting arguments at index 1.
// The first argument minigrep takes is the string we’re searching for, so we put a reference to the first argument in the variable query.
// The second argument will be the file path, so we put a reference to the second argument in the variable file_path.

// We temporarily print the values of these variables to prove that the code is working as we intend.
// Let’s run this program again with the arguments test and sample.txt:

// $ cargo run -- test sample.txt
//    Compiling minigrep v0.1.0 (file:///projects/minigrep)
//     Finished dev [unoptimized + debuginfo] target(s) in 0.0s
//      Running `target/debug/minigrep test sample.txt`
// Searching for test
// In file sample.txt

// Great, the program is working! The values of the arguments we need are being saved into the right variables.
// Later we’ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we’ll ignore that situation and work on adding file-reading capabilities instead.

// Reading a File
// Now we’ll add functionality to read the file specified in the file_path argument.
// First, we need a sample file to test it with: we’ll use a file with a small amount of text over multiple lines with some repeated words.
// Listing 12-3 has an Emily Dickinson poem that will work well!
// Create a file called poem.txt at the root level of your project, and enter the poem “I’m Nobody! Who are you?”

// With the text in place, edit src/main.rs and add code to read the file, as shown in Listing 12-4.

// use std::env;
// use std::fs;

// fn main() {
//     let args: Vec<String> = env::args().collect();

//     let query = &args[1];
//     let file_path = &args[2];

//     println!("Searching for {}", query);
//     println!("In file {}", file_path);

//     let contents = fs::read_to_string(file_path)
//         .expect("Should have been able to read the file");

//     println!("With text:\n{contents}");
// }






















